Sprint 1
Juan David Ardila Suárez
Implementar el template de login y registro
David Moriello
Tabla de categorías

Crear API

API: Agregar endpoint de categorías

Testear la API


Pablo Leonel Cristaldo
Front – Back – Infra
Implementar template general responsive
Implementación template bloque buscador
Evento de login de usuário
CRUD Categorias
Diseño de la red
Manejo de Gitlab
Correcciones de codigo


Heidy Olaya
Implementar el template del bloque Listado
​​Implementar el template del bloque Categorías
Gastón Vera
Evento de Header
Responsive
Animaciones
Rutas
Manejo de Gitlab
refactorizacion de codigo
Federico Bonesi
Colaboración y realización del footer. Planificación y ejecución de los tests manuales



Sprint 2
Juan David Ardila Suárez
Agregar bloque de imágenes y galería a template producto
David Moriello
Crear controlador de productos

Crear, listar y buscar por id al controlador de productos

Agregar relación entre producto y característica

Agregar relación entre categoría y producto

Crear tabla “imágenes” en la base de datos

Mapear la tabla “imágenes” con clases del modelo.

Agregar relación entre producto e imágenes

Crear tabla “productos” en la base de datos

Implementar filtro por ciudad en controlador

Acceso API para mostrar bloque categorías

Implementar filtro de productos por categoría 

Testeo Automatizado (Postman)
Pablo Leonel Cristaldo
Back - front – base de datos – testing - infra
Completar información del frontend de producto con datos de la API
Implementar template responsive de producto
Crear tabla “características” en la base de datos
Completar el select de ciudades con datos de la API
Crear infraestructura en AWS
Testeo Automatizado (JEST)
Crear Pipeline para CI CD
Armar el Template del Bloque Caracteristicas
Crear Template de Bloque de Politica del Producto
Manejo de Gitlab
Correcciones de codigo


Heidy Olaya
Corrección de los problemas vistos en el anterior sprint
Mejoramiento del login y register


Gastón Vera
Generar enrutador para home y productos
Implementar el consumo de API en el Front End del home
Mostrar productos aleatorios en el home
Filtro por ciudad en el buscador
Completar el select de ciudades con datos de la API
Filtrar por categoría al clickear bloque
Incluir calendario de reservas y botón para acceder
Manejo de Gitlab
refactorizacion de codigo



Federico Bonesi
Colaboración en la realización del controller de Ciudad, estableciendo relación con producto.

Planificación y ejecución de los tests manuales

Test exploratorios


Sprint 3
Juan David Ardila Suárez
Ayudé en la card de producto
David Moriello
Colaboración para  Crear la tabla de “usuarios” en la base de datos 

Colaboración para Agregar registro de usuarios a la API

Colaboración para Crear la tabla “roles” en la base de datos

Agregar autenticación con Spring Security a endpoint de usuarios

Crear tabla de “reservas” en la base de datos

Mapear las tablas “rol“, “usuarios” y ”reservas” con clases de nuestro modelo.

Crear endpoints de reservas en API con JPARepository

Agregar seguridad con token al endpoint de creación de reservas

Agregar puntajes a los productos

Tabla de favoritos

Filtrar mis favoritos por Id de Usuario
Pablo Leonel Cristaldo
Base de datos – Front – Back - Infra
Crear la tabla “roles” en la base de datos
Crear la tabla de “usuarios” en la base de datos
Agregar registro de usuarios a la API
Conectar formulario de registro de usuarios con API
Conectar formulario de login con API
Conectar botón “Cerrar Sesión” con API
Dar funcionalidad al botón de reserva en página de detalle de producto
Implementar el template pantalla de reserva
Implementar el formulario de reserva
Implementar submit del formulario de reservas
Implementar el template de reserva exitosa
Deploy en AWS  
Manejo de Gitlab
Correcciones de codigo


Heidy Olaya
Hacer ajustes a los comentarios de la PO
Rehacer la galería
Gastón Vera
Implementar búsqueda por fecha desde la página principal
Implementar filtro por ciudad e intervalo de fechas en API
Implementar un calendario interactivo en la página de reservas
Agregar ruta para reservas
Manejo de Gitlab
refactorizacion de codigo


Federico Bonesi
Planificación y ejecución de los tests manuales

Test exploratorios





Sprint 4
Juan David Ardila Suárez
Redacté la parte general del informe sobre el proyecto
David Moriello
Crear un endpoint en la API que permita filtrar reservas por Id de usuario

Crear los endpoints en la API que nos permitan actualizar un producto y buscar un producto por id

Entidad mensajes con su repositorio, servicios y controllers.

Logica para el envio de mensajes entre cliente y administrador
Pablo Leonel Cristaldo
Base de datos  –  Front  –  Back  – Infra
Crear la página de "mis reservas"
Crear la página de Todas las reservas para el administrador
Crear la pagina de Favoritos
Crear la pagina de detalle de reserva con un chat
Crear url para acceder al sitio
Implementar testing automatizado
Manejo de Gitlab
Correcciones de codigo


Heidy Olaya
Completar el form para creación de propiedades
Crear un modal para verificar esta creación
Conectar con el back end a través de una api


Gastón Vera
Implementar búsqueda por fecha desde la página principal
Implementar filtro por ciudad e intervalo de fechas en API
Implementar un calendario interactivo en la página de reservas
Agregar ruta para reservas
Manejo de Gitlab
refactorizacion de codigo


Federico Bonesi
Planificación y ejecución de los tests manuales.

Realización del informe final de testing.

Realización de la presentación para  la DEMO.


Una tabla indicando las fortalezas actuales en las principales áreas de tecnología de la carrera.
Juan David Ardila Suárez
Filósofo, Universidad Nacional de Colombia.
Editor y gestor de proyectos editoriales.
Conocimientos en programación al inicio: conocimientos básicos en Python, Java, HTML y Vue.js
Tecnología
Fortaleza
Front end
🔵 🔵 ⚪
Back end
🔵 🔵 ⚪
Infraestructura
⚪ ⚪⚪
Testing / QA
⚪ ⚪ ⚪
Bases de datos
🔵 🔵 ⚪

 


Pablo Leonel Cristaldo
Al comenzar la carrera tenía nociones básicas de programación, había realizado algunos algoritmos simples como imprimir algo en pantalla en pascal, trabajar un poco con arrays en C y realizar una pequeña aplicación a modo de calculadora con Visual Basic. 
Pase por todos los roles (muchos a la vez en todas las etapas) e hice una gran cantidad de tareas, tanto las pedidas como extras. 
Antes de este proyecto sentía que mi fortaleza estaba en backend , pero debido a diferentes circunstancias durante el proyecto no pude dedicarme a esto tanto como hubiese querido, tome la decisión en muchos momentos de dedicarle tiempo en aquellas tareas donde cada hora resultará en un mayor valor agregado en la construcción proyecto. Después de trabajar intensamente los dos meses en el front , me siento mucho más seguro en el front con React que en cualquier de los otros campos. Sin embargo me desempeñe en todas las áreas y estoy conforme con mis habilidades en todos los niveles, si nombre especialmente React es porque es necesario nombrar en el que llegue a un mayor nivel. 
Me siento muy cómodo en una posición Fullstack, quisiera entender a fondo cómo funcionan todos los procesos relacionados con un proyecto.
Tecnología
Fortaleza
Front end
🔵 🔵 🔵
Back end
🔵 🔵 🔵
Infraestructura
🔵🔵🔵
Testing / QA
🔵🔵 ⚪
Bases de datos
🔵 🔵 🔵

 
David Elías Moriello
Antes de empezar la carrera, estaba estudiando farmacia, solo tenía conocimientos básicos de HTML y CSS. 
Durante el proyecto me desempeñe principalmente como Back-End, creando las entidades, sus relaciones, servicios y controllers necesarios, el CRUD y de más consultas necesarias para que el front pueda manejar los datos de la manera más óptima posible.Además de implementar la seguridad necesaria para la aplicación.
Hoy con el proyecto integrador terminado me siento 100% backend, principalmente con JAVA pero en el futuro cercano quisiera aprender otros lenguajes principalmente GO. Creo que  puedo desempeñarme como full stack si refuerzo algunos conceptos de React e Infraestructura.
Tecnología
Fortaleza
Front end
🔵 🔵 ⚪
Back end
🔵 🔵 🔵
Infraestructura
🔵⚪⚪
Testing / QA
🔵⚪⚪
Bases de datos
🔵 🔵 🔵

 
 
Gastón Raúl Vera
Estudió Ingeniería en Sistemas, con lo cual tenía diversos conocimientos en muchas de las áreas que recorrimos. Ya había hecho algunos proyectos, por ejemplo administrando bases de datos, o escrito algoritmos.
Durante el proyecto me desempeñe principalmente en Front-End, hice cambios e implementaciones necesarias en Back End según las necesidades que se fueron presentando, así como creación de diferentes Consultas a la base de datos para generar con lenguaje nativo de MySql.
Tecnología
Fortaleza
Front end
🔵 🔵 🔵
Back end
🔵 🔵 🔵
Infraestructura
🔵⚪⚪
Testing / QA
🔵🔵 ⚪

 
Federico Bonesi
Previamente al comienzo de la carrera de Certified Tech Developer, me encontraba estudiando la carrera de administración en la FCE de la UBA (Universidad de Buenos Aires), hoy por hoy me faltaría solo la tesis para su completitud. He realizado tres materias dentro de la misma casa de estudio para la carrera de licenciatura en Sistemas de información de las organizaciones, donde puede tener un acercamiento hacia metodologías ágiles y a un símil pensamiento de la lógica de la programación.
Aún así, mi ignorancia en programación era total. Con el curso y el proceso del proyecto integrador, he adquirido muchísimo conocimiento así como también el desarrollo de habilidades blandas. 
A lo largo del proyecto integrador, he encontrado mi lugar donde mi aporte dentro del equipo se convirtió en un valor agregado y fue desempeñar el rol de QA Tester. Pude indagar sobre lo requerido, pero llevándolo un poco más allá, implementando otras herramientas como Jira, Zephyr y Xray. Y la realidad es que me gusta tal posición y quisiera profundizar. Tengo conocimientos de Selenium IDE y Web Driver que no fueron implementados por cuestión de tiempos.
Me considero una persona “Quick Learner”, lo que hoy no sé, no me toma mucho tiempo para poder comprenderlo.

Tecnología
Fortaleza
Front end
🔵 ⚪ ⚪
Back end
🔵 🔵 ⚪
Infraestructura
⚪⚪⚪
Testing / QA
🔵🔵 🔵
Bases de datos
🔵 🔵 🔵

 
 
Heidy Olaya
Tengo experiencia en atención al usuario y muy buenas relaciones interpersonales, por lo cual se me facilita el trabajo en equipo.
Manejo de JavaScript, Node.js, Express, React.js, HTML5, 
CSS3, SASS
- Bases de datos: MongoDB, MySQL, OMR: Sequilize.
- Sistemas de versionado: GIT y Git Hub.
- Alta capacidad de adaptación a los puestos de trabajo.

Tecnología
Fortaleza
Front end
🔵 🔵 🔵
Back end
🔵 🔵 ⚪
Infraestructura
⚪ ⚪⚪
Testing / QA
⚪ ⚪ ⚪
Bases de datos
🔵 🔵 ⚪

 
Metodología de trabajo
Completar esta sección respondiendo a las siguientes consignas:
Breve explicación de la metodología de trabajo utilizada (Scrum), indicando los puntos que les hayan resultado positivos y / o negativos.
Se usó una metodología Scrum. Para esto, el desarrollo se dividió en 4 sprints,cada uno con una extensión de dos semanas. Un sprint empezaba con una planificación y validación. Luego de esto, había 5 dailys, 1 weekly de 15 minutos. Al final de cada sprint se presenta el avance en un sprint review y en una retrospectiva analizamos nuestra forma de trabajar, tratando de identificar los problemas y las buenas prácticas que estábamos implementando, para evitar los primeros y continuar con las segundas.
En general fue positivo contar con un escenario en el que los integrantes del equipo pudiesen expresar sus avances y obstáculos. No obstante, este método no pudo tener completo éxito porque algunos miembros del grupo no fueron completamente transparentes acerca de los problemas que estaban teniendo. Sin embargo, el equipo se aseguró de que esto no complicara el desarrollo de cada sprint relevando a los miembros que presentaran estos problemas.
Explicación de cómo manejaron la asignación de roles dentro del equipo (si los hubo) y cómo se organizaron a la hora de repartir las tareas.
Las tareas asignadas en la planificación se organizaban en un tablero kanban con las columnas “por hacer”, “haciendo”, “por revisar”, “cerrado”. Para graficar este tablero se prefirió usar el Gitlab por facilidad. La escogencia de la tarea fue autónoma, según el nivel de conocimiento que las personas sentían que tenía. Si existía un obstáculo para cumplir con la tarea, otro individuo releva al primero. Esto con el fin de cumplir con las historias de usuario de la forma más satisfactorias posibles.
Opcionalmente pueden describir otros acuerdos a los que hayan llegado para trabajar en equipo, gestionar el control de versiones, normalizar el código producido, etc.
Para el control de versiones se usó un sistema que cuenta con tres ramas. Los cambios finales del proyecto se establecen en la rama master del repositorio. En cada sprint se debía clonar este código para asegurar que todos los desarrolladores accederían a la versión última del sprint anterior. A esta rama le seguía una rama de desarrollo, denominada “develop”, sobre la cual se trabajaba en cada sprint. Los desarrolladores crean una branch a partir del código depositado en develop. La nomenclatura de estas ramas era la siguiente “num_feature_descripción”, donde num era el número de la tarea en la lista de issues de Gitlab, y “descripción” refería a una característica notoria del issue.
Bitácora del proyecto
Completar esta sección respondiendo a las siguientes consignas:
Describir cómo vivieron cada sprint, qué desafíos se encontraron y cómo resolvieron los requerimientos obligatorios y opcionales.
Sprint 1
Desafíos
Cómo se resolvieron los requerimientos
organizacion y gestion de gitlab
delegación de tareas

 
Sprint 2
Desafíos
Cómo se resolvieron los requerimientos
Librerías con poca documentación.
Poco tiempo disponible.
Construcción de la infraestructura
Se hizo una revisión de todas las librerías disponibles y se buscó la más satisfactoria.
Comunicacion con otros equipos

 
Sprint 3
Desafíos
Cómo se resolvieron los requerimientos
Implementar seguridad con JWT 
Buscando en la documentación oficial, tutoriales en internet y hablando con otros grupos y el TL.

 
Sprint 4
Desafíos
Cómo se resolvieron los requerimientos
Solucionar bugs que se fueron generando a medida que se implementan todas las funcionalidades
Agendando reuniones entre los miembros del equipo y poniéndonos de acuerdo con los cambios que se implementan.

 
Pueden utilizar y referenciar el resultado de las dailies y las retros para este punto.
Resumir las fortalezas del equipo y cómo supieron aprovecharlas para avanzar de mejor manera.
Conocimiento técnico. La mayoría del equipo poseía un gran conocimiento en tecnologías de backend, infraestructura, testing y frontend.
Adicionalmente, poseían una gran autonomía y eso permitía que se esfuercen en buscar soluciones novedosas para los problemas del grupo.
 
Contar puntualmente algo que consideren que haya sido un éxito dentro del equipo / desarrollo.
Colaboración.
El conocimiento de ciertos miembros del equipo.
La dedicación de algunos miembros del equipo.
Resumen de debilidades del equipo y cómo resolvieron situaciones difíciles o conflictivas.
Contar puntualmente algo que consideren que haya salido mal, cómo lo resolvieron y qué aprendieron como consecuencia.
El 50% de los integrantes del equipo contaban con poco tiempo disponible para colaborar. Esto ocasionó que algunos de los integrantes del grupo tuvieran que asumir mayores responsabilidades. Se planteó como norma que se estableciera una transparencia respecto a las actividades que se estaban realizando y que si una persona experimentaba obstáculos acudiera a otros.
Tecnologías utilizadas
Completar esta sección respondiendo a las siguientes consignas:
Qué servicios / herramientas emplearon a la hora de realizar el desarrollo.
Gestión del proyecto.
Como se expuso atrás, para gestionar el proyecto se usó la kanban board de Gitlab. Algunas veces esto se complementaba con Trello, con el fin de llevar control de actividades que no estaban explícitamente resaltadas en los issues abiertos, tales como resolver asuntos dejados en sprints anteriores. Había una comunicación constante. Cuando alguien sentía que no podría finalizar una tarea dada, acudía a la ayuda de un miembro del equipo con mayor experiencia en estos asuntos.
Desarrollo del proyecto:
IDEs
Para el desarrollo del proyecto se usaron dos IDEs debido a la facilidad que presentan para el trabajo con ciertos lenguajes. Para el desarrollo de los componentes de front end optamos por Visual Studio Pro, dado que es un software libre. Dentro de las ventajas que tiene: 
Genera sugerencias de código. 
Pueden importarse extensiones para mejorar el trabajo. 
Se tiene un espacio para el control de versiones. 
Tiene integrado un terminal. 
Tiene herramientas integradas para testear el código
Optimiza el uso de memoria.
Por otro lado, el trabajo para el back end se realizó en Intellij. Esta herramienta está optimizada para el trabajo en el framework de Java, Spring boot. Como tal, tiene las siguientes características:
Provee autocompletado del código.
Inspecciona y genera sugerencias para evitar posibles errores del código.
Es fácil de utilizar. Su curva de aprendizaje es menor sobre otros IDE, como Eclipse.
La experiencia de usuario está más optimizada.
Sistemas de control de versiones
El sistema que usamos para gestionar el control de versiones es Git, ya que es gratuito y de código abierto. Las características de Git se basan en la confirmación de nuevos cambios, la ramificación, fusión y la comparación de versiones anteriores. Es eficiente y sencillo, pues tiene la capacidad de ser empleado de forma básica, además de ofrecer potencial, cantidad de prestaciones y control sobre el proyecto. 
A su vez, se usa Gitlab, que es un repositorio de gestión de proyectos. Es decir, proporciona el código para generar un servidor y gestionar los clientes, sus operaciones y los servicios que ofrece. Se puede administrar grupos de personas y sus permisos. También es posible visualizar el estado de los proyectos. Dentro de las características de Gitlab está:
Algunas de las funciones de GitLab son las siguientes: 
Es posible gestionar varios repositorios.
Es posible revisar los códigos.
Se puede localizar los errores y problemas.
Integración y entrega continua (CI/CD) de modo gratuito.
Crea de manera sencilla fragmentos de código para dividir partes del mismo.
Qué tecnologías utilizaron para el desarrollo del sitio
Front end
Para la parte de Front-end se eligió la library de javascript React. Es una de las librerías más usadas de ese lenguaje de programación. Si se plantea una comparación con otros frameworks front end, tales como Angular o Vue, React triunfa por las siguientes razones:
Puede usarse para la web o para móviles.
Es una de las soluciones más usadas junto con Vue.


En el aspecto comunitario sigue siendo fuerte React, pues el volumen de contribuyentes es más grande cuando se compara con Vue o Angular.
Según algunas páginas web, esta opción es la mejor cuando el equipo tiene experiencia trabajando con HTML, CSS o Javascript; se necesita una opción personalizada en la aplicación y existen múltiples eventos dentro de la aplicación web.
Back end
Por otro lado, se optó por el framework Spring Boot. Como tal, simplifica dos pasos en el desarrollo del back end de una aplicación, seleccionar jars y desplegarse a los servidores gracias a su uso de Tomcat. Las dependencias se obtienen a través de Spring Initalizer y a partir de esto también una estructura para trabajar.  
Además, a través de este framework se puede simplificar la creación de aplicaciones que siguen el modelo vista controlador. MVC (Modelo-Vista-Controlador) es un patrón en el diseño de software comúnmente utilizado para implementar interfaces de usuario, datos y lógica de control. Enfatiza una separación entre la lógica de negocios y su visualización.
Como características de este framework se puede encontrar la siguiente:
Evita configurar archivos XML
Proporciona una creación y actualización simple de endpoints a partir de la anotación de @restcontroller.
Desplegar la aplicación es muy sencillo gracias al  servidor Tomcat.
Se puede escalar la aplicación debido a que facilita el trabajo con una arquitectura de microservicios.
A su vez, para introducir la autorización y autenticación al proyecto se implementa la librería Spring Security. Gracias a esto, se puede controlar el acceso a los recursos del proyecto y también controlar los roles de cada usuario de tal forma que puedan acceder a los recursos que los tiene autorizado. Esto se complementó con el uso de JWT, que permite una autenticación e intercambio de información no basado en sesiones sino que e servidor introduce los datos en un JSON Web TOken (JWT) y lo envía al cliente. El cliente salva el JWT y todas sus solicitudes están relacionadas con el token.
Base de datos
Para la gestión de datos de la aplicación se usa el gestor de bases de datos relacionales MySQL. Este sistema de gestión de datos tiene las características de ser open source, estable y tener una lista de factas ricas. Es además la más usada plataforma en el mundo. Algunas características de esta herramienta son su compatibilidad. Este sistema puede ser usado en un gran número de arquitecturas y sistemas operativos. Puede proporcionar un número de back end y migrarse fácilmente a alternativas como MariaDB. Además, a diferencia de otras plataformas no relacionales, MySQL contiene múltiples, separadas y altamente codificadas tablas. Gracias a esto, MySQL puede optimizar la recopilación de datos, actualizar información, entre otras tareas.
Infraestructura
Para la gestión de la estructura se usó el AWS Elastic Beanstalk. La ventaja de esto es que es un servicio de despliegue y provisión en nube que automatiza establecer las aplicaciones en AWS. Para usar el servicio, los desarrolladores solo deben subir las aplicaciones; por otro lado, el aprovicionamiento, el balanceo de carga, la autoescalada y el monitoreo se realizan de manera automática, la gestión de los datos se hace en Amazon RDS, de esta manera se puede agregar MySQL al proyecto desplegado en AWS. Para desplegar el front end de la aplicación se usa un S3.
Testing
En primer lugar, se usó Jira software, que es una aplicación para la gestión de proyectos, seguimiento de errores e incidencias. Esto para explicar los distintos casos de uso.
También se utilizó Zephyr Squad para los manual test cases. Esta es una solución flexible de gestión de pruebas de un solo proyecto para equipos ágiles dentro de Jira. Se integra perfectamente en su entorno de Jira, por lo que los equipos ágiles familiarizados con Jira pueden empezar a realizar pruebas inmediatamente. Se cubren todos los aspectos básicos de la gestión de pruebas, incluidas las integraciones listas para usar con herramientas y marcos de automatización populares. 
A su vez, se presenta Xray con el fin de hacer el test exploratorio, una aplicación de gestión de pruebas nativa de Jira, le proporciona la estructura necesaria para organizar, planificar e informar sobre el progreso de sus pruebas y garantizar su preparación para el despliegue. 


Documentación técnica del proyecto
Esta sección la dejamos a su criterio. Básicamente debería contener toda la información técnica que pueda serle útil a los integrantes del equipo o personas que deban comprender el funcionamiento del sitio desde el lado técnico.
Algunas sugerencias:
Ambiente de desarrollo
Instrucciones de cómo un nuevo integrante debería armarse su ambiente de desarrollo

Un nuevo integrante debe clonar el repositorio https://gl.deitech.online/ctd/proyecto-integrador-0522/0621-c1/grupo-08 
Esto le da acceso a todos los elementos del proyecto.
Respecto a la parte del backend, es necesario pararse sobre la carpeta Backend
Sobre esa carpeta es necesario correr el comando en el terminal 
mvn spring-boot:run
De esta forma, el back end empieza a correr en el puerto 8080
Si se desea trabajar en el front end de la aplicación es necesario estar parado sobre la carpeta FrontEnd y allí correr la instrucción en el terminal “npm install” para que se instalen las dependencias necesarias para correr el proyecto. 
Luego de esto, se da la instrucción en el terminal “npm start” y se abre el servidor en el puerto 3000.

Buenas prácticas / convenciones / acuerdos a la hora de desarrollar
El código debía ser limpio. Lo que esto quiere decir es que es fácil de leer, la lógica es directa, los nombres de los distintos elementos son precisos y directos, ofrece solo una manera de hacer algo.
Adicionalmente, se trata de que si se recibe un código que otra persona dejó y este no cumple con requisitos, es necesario que se colabore para que cumpla con los requisitos de limpieza. Esto no significa refactorizar, sino simplemente hacer ajustes que mejoren la legibilidad. 
Se prefiere el camel case. En el caso de frontend, cada función está ligada a un componente, que está asociado a una subcarpeta en “components”. Las carpetas de los componentes van en minúscula. Cada carpeta de un componente tiene un archivo jsx con el nombre “index.jsx” y un css como “index.css”. Los nombres de las clases deben ser específicos para cada componente para evitar que se pisen los estilos de un componente en los de otros.
Con respecto al backend,se siguen las siguientes convenciones de nombres:
Atributos. Los nombres de los atributos comienzan con minúscula, si necesitamos usar más de una palabra, a partir de la segunda inicializamos en mayúscula. **elAtributo**
Métodos. Se nombran de la misma forma que los atributos, la primera palabra en minúscula y si el nombre tuviera más palabras, todas se inicializan en mayúscula. Recomendamos poner nombres lo más descriptivos posibles, aunque esto implique usar varias palabras. calculoSueldoNeto
Objetos. La primera palabra en minúscula y si tiene más de una palabra, las siguientes se inicializan en mayúscula. nombre, importeTotal
Clases. Los nombres de las clases siempre van con la inicial en mayúscula, si necesitamos usar dos o más palabras para nombrar una clase van pegadas y con todas las iniciales en mayúscula. CamelCase, Empleado
Paquetes. Todas las letras en minúsculas.
Constantes. Todas las letras en mayúscula y si hay más de una palabra, separadas por guión. IVA, DIAS_SEMANA
Los componentes deben ser pequeños de tal forma que puedan reusarse para cumplir otras funciones.
Los tests deben ser rápidos, independientes, repetibles, validarse

Buenas prácticas respecto a los commits, merges y el uso de branches
Algunas buenas prácticas que se siguieron con respecto al trabajo son las siguientes: 
Los commits debían tener un único propósito, y no se debían enviar commits incompletos. Un ejemplo de estos propósitos serían solucionar un bug o agregar una nueva funcionalidad. 
Se debía escribir mensajes en los commits que fueran lo suficientemente específicos.
 
Base de datos
Estructura y diagramas


Componentes y diagramas de la aplicación
Principales partes de la aplicación y cómo se conectan
La aplicación tiene tres partes principales, un backend elaborado en Springboot. El propósito de este es generar las rest api que serán consumidas por el frontend y gestionar estos datos con la base de datos de MySQL. Existen 8 clases en la aplicación, ciudades, categorías, imágenes, productos, reservas, puntuaciones, políticas, descripciones. A partir de los Data Transfer Object (DTO) de estas clases, se crean rest apis para ser consumidas por el frontend. Adicionalmente, hay unas clases que se vinculan a la autorización y autenticación de la aplicación, como son las de usuario, reserva y rol. Todas las clases tienen una parte en la que se consideran las excepciones. Para la autorización y autenticación se usó Spring Security y JWT, como se vio atrás.
En el frontend se consumen las apis establecidas en el backend, para esto se cuenta con una carpeta de componentes de servicios donde se da el consumo de las apis de categorías, ciudades, productos, reservas, usuarios. Adicionalmente, hay una carpeta de pages donde: 
El filtro por varios criterios, como cada una de las features, 
Se desarrolla la lógica de funcionalidades como las cards de las categorías en el home. 
El login, que está validado a partir de hooks. 
Registro, que también usa esa forma de validación.
Las reservas que ha realizado un usuario.
El producto, donde se presenta la descripción de las fechas disponibles, la galería de las fotos de los productos, features, descripción, ubicación, el slider.
Hay asimismo una carpeta components donde se encuentran elementos que se reutilizan a lo largo de la página:
El spiner.
La búsqueda.
El calendario.
El header y el footer.
El dropdown menu.
El filtro múltiple.
Los enlaces del frontend siguen la lógica del single page app, que optimiza el cambio entre recursos web. Esto se hace a través de React Router.
APIs disponibles y su documentación (pueden linkear a un sitio externo)
Infraestructura
Estructura y diagramas
Para desplegar el backend de la aplicación se cuenta con Amazon Beanstalk. Este servicio tiene la funcionalidad de desplegar y escalar aplicaciones que soporta Java. Para desplegar la base de datos se usa una instancia RDS Amazon RDS es un servicio web que permite desplegar y escalar rápidamente escalar una base de datos relacional en la nube de Amazon. Una vez que haya desplegado su base de datos, es posible administrarla mediante una herramienta de administración normal como MySQL Workbench. Por último, para desplegar el front end de React se usa un S3. S3 significa Simple Storage Service, que es un almacenamiento escalable en la nube. S3 es básicamente un almacén de objetos.
Un diagrama similar al de nuestra aplicación se puede ver a continuación.

Testing y calidad
Incluir el informe requerido para el cuarto sprint y cualquier otra información referente a cómo buscaron asegurar la calidad del software producido.
https://docs.google.com/document/d/1efaOa-7YZpe-umDiZ9YwSXkp1wHLbTqK0RDnSo05edk/edit?usp=sharing



